/* The core logic behind this algorithm is that, we first push elements in stack and then remove it from stack once we found a greater element.
Traverse input array from left to right.
Push first element of array in stack.
For any element inputArray[i], compare it with top element of stack(top).
If inputArray[i] <= top, then push inputArray[i] in stack.
If inputArray[i] > top, then inputArray[i] is next greater element of top. Keep on removing top elements of stack until inputArray[i] > top.
After complete traversal of inputArray, stack is non-empty then no next greater element exists for those elements inside stack. */



#include <stdio.h>
#include <string.h>
  
#define MAXSIZE 100
#define TRUE 1
#define FALSE 0 
  
struct Stack {
    int top;
    int array[MAXSIZE];
} st;

void initialize() {
 st.top = -1;
}
  
int isFull() {   
    if(st.top >= MAXSIZE-1)
        return TRUE;
    else
        return FALSE;
}
  
int isEmpty() {
 if(st.top == -1)
     return TRUE;
 else
     return FALSE;
}

void push(int num) {
    if (isFull())
        printf("Stack is Full...\n");
    else {
        st.array[st.top + 1] = num;
        st.top++;
    }
}
  

int pop() {
    if (isEmpty())
        printf("Stack is Empty...\n");
    else {
     st.top = st.top - 1;
        return st.array[st.top+1];
    }
}

void printNextBigElement(int *array, int size) {
    initialize();
    int top, current, i;
  
    push(array[0]);
  
    for(i = 1; i < size; i++){
        current = array[i];
  
        if (!isEmpty()) {
            top = pop();
    
            while(top < current) {
                printf("%d  %d\n", top, current);
                if(isEmpty())
                     break;
                top = pop();
            }
  
            if (top >= current)
                push(top);
        }
  
        push(current);
    }
  
    while (!isEmpty()){
        top = pop();
        printf("%d  %d\n", top, -1);
    }
}
int main() {
    int i, array[6]= {7, 4, 10, 8, 1, 14};
    printNextBigElement(array, 6);
 
    return 0;
}
